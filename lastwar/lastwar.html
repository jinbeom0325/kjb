<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>

    <style>
      * {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}


#start_button {
  display: block;
  width: 200px;
  height: 50px;
  background-color: #343b34;
  opacity: 0.8;
  color: #fff;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  margin: 5px 0px;
}


#start_button:hover {
  cursor: pointer;
  opacity: 1.3;
}


.title {
  display: flex;
  position: absolute;
  width: 80vw;
  height: 100vh;
  color: #f7f7f7;
  font-size: 2rem;
  background-image: url("lastwar_title.jpg");
  background-size: contain; /* 이미지가 왜곡되지 않도록 설정 */
  background-position: center;
  background-repeat: no-repeat; /* 이미지 반복 방지 */
  top: 0;
  text-align: center;
  align-items: center;
  justify-content: center;
  z-index: 2; /* canvas 위에 오도록 설정 */
}


body {
  background-color: #000000;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}


.game-container {
  position: relative;
  width: 80vw;
  height: 100vh;
  max-width: 400px;
  max-height: 100vh;
  background-color: #e5e5e5;
  display: flex;
  justify-content: center;
}


canvas {
  width: 100%;
  height: 100%;
  max-width: 400px;
  /* max-height: 700px; */
  display: block;
  background-color: #c0c0c0;
}


#result_screen {
  display: none;
  position: fixed;
  width: 50vw;
  height: 80vh;
  color: #f7f7f7;
  font-size: 1rem;
  /* background-image: url("lastwar_result.jpg"); */
  background-color: rgb(138, 191, 216);
  background-size: contain;
  background-position: center;
  background-repeat: no-repeat;
  top: auto;
  text-align: center;
  align-items: center;
  justify-content: center;
  z-index: 2;
  border-radius: 10px;
  border: 2px solid black;
}


#result_screen ol {
  /* display: flex; */
  /* flex-wrap: wrap; */
  list-style: none;
  /* position: relative; */
  text-align: center;
  justify-content: space-between;
  width: 100%;
  height: 35%;
}


#result_screen ol p {
  font-size: 10px;
  display: inline;
  padding: 3px;
  font-weight: bolder;
}


h3 img {
  width: 100%;
  max-width: 250px;
  height: 150px;
  display: block;
  margin: auto;
}


#result_screen ol li {
  display: flex;
  float: left;
  color: rgb(102, 102, 102);
  justify-content: space-between;
  width: 100%;
  display: block;
}


#firstli {
  color: skyblue;
}


#result_screen ol li {
  background-color: rgb(255, 255, 255);
}


#result_screen ol li:nth-child(even) {
  background-color: rgb(228, 228, 228);
}


#re-stage {
  width: 80%;
  margin: auto;
  display: flex;
  align-items: center;
}


#prevstage {
  width: 100px;
  max-width: 100px;
  display: block;
  height: 30px;
  margin: auto;
  border-radius: 10px;
  background-color: rgba(250, 110, 110, 0.788);
  opacity: 0.7;
}


#prevstage:hover {
  cursor: pointer;
  opacity: 1.3;
}


#nextstage:hover {
  cursor: pointer;
  opacity: 1.3;
}
#nextstage {
  width: 100px;
  max-width: 100px;
  display: block;
  height: 30px;
  margin: 10px auto;
  border-radius: 10px;
  background-color: #699cfc;
  opacity: 0.7;
}


#restart_button {
  width: 80%;
  max-width: 200px;
  height: 10%;
  margin: 5px 0px auto;
  border-radius: 10px;
}


#restart_button:hover {
  font-size: 25px;
  cursor: pointer;
  background-color: #786bbe;
}


#text_box {
  display: block;
  width: 100%;
  max-width: 200px;
  margin: 5px 0px;
}


#stage_box {
  width: 100%;
  height: 20px;
  /* background-color: #8d7272; */
  display: flex;
  justify-content: space-between;
}


#left_btn {
  /* float: left; */
  width: 20px;
  height: 100%;
  background-image: url(left.png);
  background-size: cover;
  background-repeat: no-repeat;
}


#level {
  width: 100px;
  height: 100%;
  display: block;
  font-size: 15px;
  font-weight: 800;
  color: rgb(255, 0, 0);
}


#right_btn {
  /* float: right; */
  width: 20px;
  height: 100%;
  background-image: url(right.png);
  background-size: cover;
  background-repeat: no-repeat;
}


#btn-box {
  position: relative;
  top: 50px;
  text-align: center;
  align-items: center;
}


#control_box {
  display: block;
  position: absolute;
  right: 30px;
  top: 10px;
  width: 30px;
  height: 30px;
  background-color: #6e5f5f;
  z-index: 1;
}


#stop_btn {
  width: 100%;
  height: 100%;
  background-image: url(https://thumb.silhouette-ac.com/t/fa/fadba6db839c36f9c6876396e55083df_t.jpeg);
  background-size: cover;
  background-repeat: no-repeat;
}


#stop_btn:hover {
  cursor: pointer;
}


#restart {
  width: 100%;
  height: 100%;
  background-image: url(https://cdn-icons-png.flaticon.com/512/8215/8215315.png);
  background-size: cover;
  background-repeat: no-repeat;
}


#restart:hover {
  cursor: pointer;
}


#reset_btn {
  width: 100%;
  height: 100%;
  background-image: url(https://previews.123rf.com/images/barks/barks1712/barks171200875/91794984-%EC%9E%AC%EC%83%9D-%EB%8F%8C%EC%95%84-%EA%B0%80%EA%B8%B0-%EC%95%84%EC%9D%B4%EC%BD%98.jpg);
  background-size: cover;
  background-repeat: no-repeat;
}


#reset_btn:hover {
  cursor: pointer;
}


#rename {
  width: 80%;
  max-width: 200px;
  display: block;
  margin: auto;
}


#viewstage {
  width: 100px;
  height: 20px;
  display: block;
  position: absolute;
  left: 30px;
  top: 10px;
  z-index: 1;
  color: yellow;
}

    </style>
  </head>
  <body>
    <div id="start_screen" class="title">
      <div id="btn-box">
        <div id="stage_box">
          <button id="left_btn"></button>
          <p id="level"><span id="level_number">1</span> Stage</p>
          <button id="right_btn"></button>
        </div>
        <input type="text" id="text_box" placeholder="이름을 입력하세요"></input>
        <button type="button" id="start_button">게임 시작</button>
      </div>
    </div>
    <div id="result_screen">
      <!-- <div id="result_text">랭킹</div> -->
      <h3 style="color: black;"> <img src="src/Logo.png" alt="">랭킹</h3>
      <ol id="ranking">
        <li id="firstli"><p>순위</p><p>이름</p><p>스테이지</p><p>플레이시간</p><p>점수</p></li>
      </ol>
      </table>
      <input type="text" id="rename" placeholder="이름을 입력하세요">
      <button type="button" id="restart_button">다시 시작</button>
      <div id="re-stage">
        <button type="button" id="prevstage">이전 스테이지</button>
        <button type="button" id="nextstage">다음 스테이지</button>
      </div>
    </div>
    <div id="game_screen" class="game-container" style="display: none">
      <canvas id="gameCanvas"></canvas>
      <div id="control_box">
        <button id="stop_btn"></button>
        <button id="restart"></button>
        <button id="reset_btn"></button>
      </div>
      <div id="viewstage"></div>
    </div>
    <script>
      const restart_button = document.getElementById("restart_button");
const result_screen = document.getElementById("result_screen");
const result_text = document.getElementById("result_text");
const input = document.getElementById("text_box");
const ranking = document.getElementById("ranking");
const ul = document.getElementById("ul");
const start_button = document.getElementById("start_button");
const start_screen = document.getElementById("start_screen");
const game_screen = document.getElementById("game_screen");
const stop_btn = document.getElementById("stop_btn");
const restart = document.getElementById("restart");
const canvas = document.getElementById("gameCanvas");
const reset_btn = document.getElementById("reset_btn");
const ctx = canvas.getContext("2d");
const rename = document.getElementById("rename");
const level_number = document.getElementById("level_number");
const left_btn = document.getElementById("left_btn");
const right_btn = document.getElementById("right_btn");
const prevstage = document.getElementById("prevstage");
const nextstage = document.getElementById("nextstage");
const viewstage = document.getElementById("viewstage");


let rankingList = [];
let maps = [];
let frame = 0;
let playtime = 0;
let score = 0;
let gameset = false;
let loop;
let playerNumber = 1;
let playerName = NaN;
let ratio = 1;
let monsterInterval = 0;
let stageNumber = 1;


restart_button.addEventListener("click", () => {
  // location.reload();
  re_start();
  console.log("restart");
});


restart.addEventListener("click", () => {
  location.reload();
});


stop_btn.addEventListener("click", () => {
  gameset = gameset === true ? false : true;
});


reset_btn.addEventListener("click", () => {
  reset(maps[0]);
});


left_btn.addEventListener("click", () => {
  decNum();
});


right_btn.addEventListener("click", () => {
  incNum();
});


prevstage.addEventListener("click", () => {
  decNum();
  stageLevel(stageNumber);
  viewstage.innerHTML = stageNumber + " stage";
  // reset(maps[0]);
  re_start();
  console.log("prev");
});


nextstage.addEventListener("click", () => {
  incNum();
  stageLevel(stageNumber);
  viewstage.innerHTML = stageNumber + " stage";
  // reset(maps[0]);
  re_start();
  console.log("next");
});


class Map {
  constructor() {
    this.canvas = canvas;
    this.ctx = ctx;
    this.backgroundImage = new Image();
    this.backgroundImage.src = "src/background1.png";


    this.bulletImage = new Image();
    this.bulletImage.src = "src/bluebullet.png";


    this.monsterImages = [
      [new Image(), new Image()],
      [new Image(), new Image()],
    ];


    this.monsterImages[0][0].src = "src/monster1.png";
    this.monsterImages[0][1].src = "src/monster1-1.png";
    this.monsterImages[1][0].src = "src/monster2.png";
    this.monsterImages[1][1].src = "src/monster2-1.png";


    this.playerImage = new Image();
    this.playerImage.src = "src/player.png";


    this.player = new Player(this);


    this.monsters = [];
    this.bullets = [];
    this.items = [];


    this.attackPowerTimer = null; // 공격력 증가 타이머
    this.attackSpeedTimer = null; // 공격 속도 증가 타이머
    this.attackInterval = 400; // 기본 공격 주기


    this.itemImages = [new Image(), new Image(), new Image()];
    this.itemImages[0].src = "src/item1.png"; //공격력
    this.itemImages[1].src = "src/item2.png"; //공격속도
    this.itemImages[2].src = "src/item3.png"; //인구수증가


    this.setitems();


    this.mobInterval = monsterInterval;
    this.setupControls();
    this.setMonsters(this.mobInterval);


    this.backgroundImage.onload = () => {
      this.canvas.width = this.backgroundImage.width;
      this.canvas.height = this.backgroundImage.height;
      this.gameLoop();
    };

    this.attackIntervalTimer = setInterval(() => {
      this.player.attack();
    }, this.attackInterval);
  }


  setupControls() {
    window.addEventListener("keydown", (event) => {
      if (event.key === "ArrowLeft") this.player.moveLeft = true;
      if (event.key === "ArrowRight") this.player.moveRight = true;
    });
    window.addEventListener("keyup", (event) => {
      if (event.key === "ArrowLeft") this.player.moveLeft = false;
      if (event.key === "ArrowRight") this.player.moveRight = false;
    });
  }


  setMonsters(mobInterval) {
    if (this.monsterIntervalId) {
      clearInterval(this.monsterIntervalId);
    }
    this.monsterIntervalId = setInterval(() => {
      if (gameset == true) {
        const canvasCenterX = this.canvas.width / 2;
        const minX = canvasCenterX - 170;
        const maxX = canvasCenterX + 150;
        let lane = minX + Math.random() * (maxX - minX); // minX부터 maxX 사이의 랜덤 값
        this.monsters.push(new Monster(this, lane));
        console.log(mobInterval);
      }
    }, mobInterval);
  }


  setitems() {
    setInterval(() => {
      const lanes = [this.canvas.width/2-160,this.canvas.width/2+100]; //아이템 등장 좌표 원래+100씩
      const lane2 = lanes[Math.floor(Math.random() * lanes.length)]; 

      this.items.push(new Item(this, lane2)); //map,좌표
    }, 3000); 
  }

  itemscheck() {
  this.items.forEach((item) => {
    // 박스 크기 계산
    let boxWidth = 140; // 기본 박스 크기
    let boxHeight = 130;
    let boxX = item.x - 35; // 기본 위치

    if (item.y >= 0) {
      let boxSize = item.y * 0.25; // y값 증가에 따라 박스 확대
      if (item.x < this.canvas.width / 2) {
        boxX -= boxSize; // 왼쪽 박스 확장
      }
      boxWidth += boxSize; // 오른쪽 확장
    }

    // 박스를 기준으로 충돌 감지
    if (
      this.player.x < boxX + boxWidth &&
      this.player.x + this.player.width > boxX &&
      this.player.y < item.y - 30 + boxHeight &&
      this.player.y + this.player.height > item.y - 30
    ) {
      if (item.type === 2) {
        console.log("인구수 증가 아이템 효과 시작");
        Player.charcters += item.number; // 아이템 숫자만큼 병사 수 증가
        console.log("현재 병사 수: " + Player.charcters);
        this.items = this.items.filter((i) => i !== item); // 아이템 제거
      }
    }
  });
}

  
  itemscheck2() {
    this.items.forEach((item) => {
        if (item.number >= 1 && item.type !== 2) {
            // 아이템의 숫자가 1 이상이고, 인구 증가 아이템이 아닐 때

            if (item.type === 0) {
                //  공격력 증가 아이템
                console.log("공격력 증가 아이템 효과 시작");
                this.player.changebullet("src/redbullet.png");
                this.player.attackPower = 2;

                // 기존 타이머가 있다면 제거
                clearTimeout(this.attackPowerTimer);

                // 10초 후 원래 상태로 되돌리기
                this.attackPowerTimer = setTimeout(() => {
                    console.log("공격력 증가 아이템 효과 종료");
                    this.player.attackPower = 1;
                    this.player.changebullet("src/bluebullet.png");
                }, 10000);

            } else if (item.type === 1) {
                // 공격 속도 증가 아이템
                console.log("공격 속도 증가 아이템 효과 시작");

                // 기존 공격 속도 타이머 제거
                clearInterval(this.attackIntervalTimer);

                // 공격 속도를 증가시켜 총알 발사 속도 조정
                this.attackInterval = 100;
                this.attackIntervalTimer = setInterval(() => {
                    this.player.attack();
                }, this.attackInterval);

                // 10초 후 공격 속도를 원래대로 되돌림
                clearTimeout(this.attackSpeedTimer);
                this.attackSpeedTimer = setTimeout(() => {
                    console.log("공격 속도 증가 아이템 효과 종료");
                    clearInterval(this.attackIntervalTimer);
                    this.attackInterval = 400;
                    this.attackIntervalTimer = setInterval(() => {
                        this.player.attack();
                    }, this.attackInterval);
                }, 10000);
            }

            //  아이템 효과 적용 후 리스트에서 제거
            this.items = this.items.filter((i) => i !== item);
        }
    });
}


  hitcheck() {
    this.monsters.forEach((monster) => {
      if (
        this.player.x < monster.x + monster.width &&
        this.player.x + this.player.width > monster.x &&
        this.player.y < monster.y + monster.height &&
        this.player.y + this.player.height > monster.y
      ) {
        console.log("hit");
        Player.charcters -= 1;
        console.log("병사 수 감소: " + Player.charcters);
        this.monsters = this.monsters.filter((m) => m !== monster);
      }
    });
    this.bullets.forEach((bullet) => {
      this.monsters.forEach((monster) => {
        if (
          bullet.x < monster.x + monster.width &&
          bullet.x + bullet.width > monster.x &&
          bullet.y < monster.y + monster.height &&
          bullet.y + bullet.height > monster.y
        ) {
          monster.hit(this.player.attackPower);
          this.bullets = this.bullets.filter((b) => b !== bullet);
        }
      });
    });
    // 총알과 아이템의 충돌 처리
    this.bullets.forEach((bullet, index) => {
  this.items.forEach((item) => {
    // 아이템 박스 크기 계산 (y 값이 증가할수록 박스 커짐)
    let boxWidth = 140;
    let boxHeight = 130;
    let boxX = item.x - 35;

    if (item.y >= 0) {
      let boxSize = item.y * 0.25;

      if (item.x < this.canvas.width / 2) {
        boxX -= boxSize; // 왼쪽 방향으로 확장
      }
      boxWidth += boxSize; // 오른쪽 방향으로 확장
    }

    if (
      bullet.x < boxX + boxWidth && // 박스의 오른쪽 경계
      bullet.x + bullet.width > boxX && // 박스의 왼쪽 경계
      bullet.y < item.y - 30 + boxHeight && // 박스의 아래쪽 경계
      bullet.y + bullet.height > item.y - 30 // 박스의 위쪽 경계
    ) {
      console.log("bullet item hit");
      item.itemcount(); // 아이템 숫자 증가
      this.bullets.splice(index, 1); // 총알 삭제
    }
  });
});
        


    if (Player.charcters <= 0) {
      game(gameset);
    }
  }


  gameLoop() {
    if (gameset == true) {
      this.update();
      this.render();
      this.hitcheck();
      this.itemscheck(); //인구수 증가 아이템 체크
      this.itemscheck2(); //공격력,공격속도 아이템 체크


      frame += 1;
      if (frame == 60) {
        playtime += 1;
        frame = 0;
      }
    }
    loop = requestAnimationFrame(() => this.gameLoop());
  }


  update() {
    this.player.update();
    this.monsters.forEach((monster) => monster.update());
    this.bullets.forEach((bullet) => bullet.update());
    this.items.forEach((item) => item.update());
  }


  render() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.drawImage(
      this.backgroundImage,
      0,
      0,
      this.canvas.width,
      this.canvas.height
    );
    this.player.draw();
    this.monsters.forEach((monster) => monster.draw());
    this.bullets.forEach((bullet) => bullet.draw());
    this.items.forEach((item) => item.draw());
  }
}


class Player {
  static charcters = 1;
  constructor(map) {
    this.map = map;
    this.x = map.backgroundImage.width / 2 - 25;
    this.y = map.backgroundImage.height - 300;
    this.width = 120;
    this.height = 120;
    this.speed = 20;
    this.moveLeft = false;
    this.moveRight = false;
    this.attackPower = 1; //기본 공격력 1
    this.bulletspeed = 5; //총알 속도
  }


  get PosX() {
    return this.x;
  }


  get PosY() {
    return this.y;
  }


  get Position() {
    return this.x, this, y;
  }


  update() {
    if (this.moveLeft && this.x > 0) this.x -= this.speed;
    if (this.moveRight && this.x < this.map.canvas.width - this.width)
      this.x += this.speed;
    // console.log(this.getPosX());
    // console.log(this.getPosY());
  }


  attack() {
    const bullet = new Bullet(
      this.map,
      this.x + this.width / 2,
      this.y,
      this.bulletImage,
      this.bulletspeed
    );
    this.map.bullets.push(bullet);
  }


  changebullet(newbullet) {
    //공격아이템 획득하면 이미지 변경
    this.map.bulletImage.src = newbullet;
  }


  calc(i) {
    if (i % 5 == 0) {
      return 0;
    } else if (i % 5 == 1) {
      return 20;
    } else if (i % 5 == 2) {
      return -20;
    } else if (i % 5 == 3) {
      return 40;
    } else if (i % 5 == 4) {
      return -40;
    }
  }


  calc2(charcters) {
    if (charcters % 5 == 1) {
      this.charcters_x_size[0] = [this.x - this.width / 2];
      this.charcters_x_size[1] = [this.x + this.width / 2];
    } else if (charcters % 5 == 2) {
      this.charcters_x_size[0] = [this.x - this.width / 2];
      this.charcters_x_size[1] = [this.x + this.width + this.width / 2];
    } else if (charcters % 5 == 3) {
      this.charcters_x_size[0] = [this.x - this.width - this.width / 2];
      this.charcters_x_size[1] = [this.x + this.width + this.width / 2];
    } else if (charcters % 5 == 4) {
      this.charcters_x_size[0] = [this.x - this.width - this.width / 2];
      this.charcters_x_size[1] = [
        this.x + this.width + this.width + this.width / 2,
      ];
    } else if (charcters % 5 == 0) {
      this.charcters_x_size[0] = [
        this.x - this.width - this.width - this.width / 2,
      ];
      this.charcters_x_size[1] = [
        this.x + this.width + this.width + this.width / 2,
      ];
    }
  }


  draw() {
    for (let i = 0; i < Player.charcters; i++) {
      let y = Math.floor(i / 3) * 20;
      this.map.ctx.drawImage(
        this.map.playerImage,
        this.x + this.calc(i),
        this.y + y,
        this.width,
        this.height
      );
    }
    // 체력
  }
}


class Bullet {
  constructor(map, x, y, image) {
    this.map = map;
    this.x = x;
    this.y = y;
    this.width = 50;
    this.height = 80;
    this.speed = 20;
    this.image = image;
  }


  update() {
    this.y -= this.speed;
    if (this.y < 0) {
      this.map.bullets = this.map.bullets.filter((bullet) => bullet !== this);
    }
  }


  draw() {
    this.map.ctx.drawImage(
      this.map.bulletImage,
      this.x,
      this.y,
      this.width,
      this.height
    );
  }
}


class Monster {
  constructor(map, x) {
    this.map = map;
    this.x = x;
    this.y = 0;
    this.width = 50;
    this.height = 50;
    this.speed = 1;
    this.hp = 1 * ratio;
    this.type = Math.floor(Math.random() * 2);
    this.imageFrames = this.map.monsterImages[this.type];
    this.frame = 0;
    this.move = 1;
    this.minXrange = this.x - 10;
    this.maxXrange = this.x + 10;


    setInterval(() => {
      this.frame = this.frame === 0 ? 1 : 0;
    }, 300);
  }


  hit(damage) {
    //몬스터 hp
    this.hp -= damage;
    if (this.hp <= 0) {
      this.map.monsters = this.map.monsters.filter(
        (monster) => monster !== this
      );
      score += 20;
    }
  }


  update() {
    //몬스터 속도
    this.y += this.speed;
    this.monstermove();
  }


  monstermove() {
    this.x += this.move;
    if (this.y < 1500) {
      if (this.x >= this.maxXrange) {
        this.move = -1;
        this.maxXrange = Math.min(
          this.map.canvas.width - this.width,
          this.maxXrange + 30
        );
      } else if (this.x <= this.minXrange) {
        this.move = 1;
        this.minXrange = Math.max(0, this.minXrange - 60);
      }
    } else {
      if (this.x <= this.map.player.PosX) {
        this.move = 1;
      } else if (this.x >= this.map.player.PosX) {
        this.move = -1;
      }
    }
  }


  getPosX() {
    return this.x;
  }


  getPosY() {
    return this.y;
  }


  draw() {
    if (this.y < 50) {
      // 이미지 증가
      this.map.ctx.drawImage(
        this.imageFrames[this.frame],
        this.x,
        this.y,
        this.width,
        this.height
      );
    } else if (this.y < 150) {
      this.map.ctx.drawImage(
        this.imageFrames[this.frame],
        this.x,
        this.y,
        this.width + 15,
        this.height + 15
      );
    } else if (this.y < 250) {
      this.map.ctx.drawImage(
        this.imageFrames[this.frame],
        this.x,
        this.y,
        this.width + 30,
        this.height + 30
      );
    } else if (this.y < 400) {
      this.map.ctx.drawImage(
        this.imageFrames[this.frame],
        this.x,
        this.y,
        this.width + 45,
        this.height + 45
      );
    } else {
      this.map.ctx.drawImage(
        this.imageFrames[this.frame],
        this.x,
        this.y,
        this.width + 60,
        this.height + 60
      );
    }


    this.map.ctx.fillStyle = "black";
    this.map.ctx.fillRect(this.x + 3, this.y - 6, this.width + 3, 5); // 체력바(길이, 두께)
    this.map.ctx.fillStyle = "red";
    this.map.ctx.fillRect(
      this.x + 3,
      this.y - 6,
      ((this.width + 3) * this.hp) / ratio,
      5
    ); // 체력 3칸
  }
}


class Item {
  constructor(map, x) {
    this.map = map;
    this.x = x;
    this.y = 0;
    this.width = 100;
    this.height = 100;
    this.speed = 2;
    this.type = Math.floor(Math.random() * 3); // 랜덤으로 아이템 종류 결정
    if (this.type === 0 || this.type === 1) {
      this.number = Math.floor(Math.random() * 4) - 5; // -5부터 -2 사이의 값
    } else {
      this.number = Math.floor(Math.random() * 3) - 5; // -5부터 -3 사이의 값
    }
  }


  itemcount() {
    this.number += 1; // 맞추면 숫자 증가
  }

  update() {
    this.y += this.speed;

  }

  draw() {
    // 아이템 이미지
    this.map.ctx.drawImage(
      this.map.itemImages[this.type],
      this.x,
      this.y,
      this.width,
      this.height
    );

    if (this.number <= -1) {
    // 빨간 박스 (0부터 파랑벽)
    this.map.ctx.fillStyle = "rgba(255, 0, 0, 0.2)"; // 반투명 빨강

    let boxWidth = 140;  //박스 넓이  
    let boxHeight = 130;   //박스 높이 
    let boxX = this.x - 35;  //아이템 에서 박스가 떨어질 위치 

    if (this.y >=0) {
        let boxSize = (this.y ) * 0.25; // y값 1늘어날때마다 0.25씩 커지게 
        if (this.x < this.map.canvas.width / 2) {
           boxX -= boxSize; //왼쪽 사이즈 확정 
        }
        boxWidth += boxSize; //오른쪽 늘어나는거 확정
    }
    this.map.ctx.fillRect(boxX, this.y-30, boxWidth, boxHeight);
    this.map.ctx.strokeRect(boxX, this.y-30, boxWidth, boxHeight);

    this.map.ctx.fillStyle = "white";  //글자 위치 수정 
    this.map.ctx.font = "50px gothic"; 
    if(this.x < this.map.canvas.width / 2) 
    {
      this.map.ctx.fillText(this.number, this.x - 100, this.y + 50);

    }else{
      this.map.ctx.fillText(this.number, this.x + 100, this.y + 50); 
    }
  
} else {
    // 파란 박스 (아이템 숫자 박스)
    this.map.ctx.fillStyle = "rgba(0, 0, 255, 0.2)"; // 반투명 파랑
    let boxWidth = 140;
    let boxHeight = 130;
    let boxX = this.x - 35;

    if (this.y >= 0) {
        let boxSize = (this.y) * 0.25; // y값이 증가할수록 박스 커짐

        if (this.x < this.map.canvas.width / 2) {
            boxX -= boxSize; //왼쪽 사이즈 확정 
        }
         boxWidth += boxSize; //오른쪽 늘어나는거 확정 
    }
    this.map.ctx.fillRect(boxX, this.y-30, boxWidth, boxHeight);
    this.map.ctx.strokeRect(boxX, this.y-30, boxWidth, boxHeight);

    this.map.ctx.fillStyle = "white";   
    this.map.ctx.font = "50px gothic"; 

    if(this.x < this.map.canvas.width / 2) 
    {
      this.map.ctx.fillText(this.number, this.x - 100, this.y + 50);

    }else{
      this.map.ctx.fillText(this.number, this.x + 100, this.y + 50); 
    }
  }
    }
  }
// window.onmousemove = (e) => {
//   console.log(e.offsetX, e.offsetY);
// };

function reset(map) {
  map.bullets = [];
  map.monsters = [];
  map.items = [];
  map.player.x = map.canvas.width / 2 - map.player.width / 2;
  map.player.y = map.canvas.height - map.player.height - 10;
  score = 0;
  playtime = 0;
  frame = 0;
  Player.charcters =1;
  // cancelAnimationFrame(loop); // 게임 루프 중지
}


function stageLevel(num) {
  // ratio = ratio * num;
  ratio = 3 * num;
  monsterInterval = 700 - num * 100;
  // boss.hp = boss.hp * ratio * 2;
  maps.forEach((map) => {
    map.setMonsters(monsterInterval);
  });
}


function re_start() {
  reset(maps[0]);
  result_screen.style.display = "none";
  // gameset = gameset === true ? false : true;
  gameset = true;
  if (rename.value != "") {
    playerName = rename.value;
  } else {
    playerName = "None";
  }
}


function game(state) {
  if (state == false) {
    start_screen.style.display = "none";
    game_screen.style.display = "block";
    result_screen.style.display = "none";


    stageLevel(stageNumber);
    viewstage.innerHTML = stageNumber + " stage";
    const map = new Map();
    maps.push(map);
  } else if (state == true) {
    gameset = false;
    result_screen.style.display = "block";
    var newli = document.createElement("li");
    newli.innerHTML =
      playerNumber +
      ". " +
      playerName +
      "\t" +
      stageNumber +
      "stage \t" +
      playtime +
      "초 \t" +
      score +
      "점";
    ranking.appendChild(newli);
    playerNumber += 1;
    console.log(rankingList);
    console.log(gameset);
  }
}


function decNum() {
  if (stageNumber > 1) {
    stageNumber -= 1;
    level_number.innerHTML = stageNumber;
    console.log(stageNumber);
  } else {
    stageNumber = 1;
    level_number.innerHTML = stageNumber;
    console.log(stageNumber);
  }
}
function incNum() {
  if (stageNumber < 5) {
    stageNumber += 1;
    level_number.innerHTML = stageNumber;
    console.log(stageNumber);
  } else {
    stageNumber = 5;
    level_number.innerHTML = stageNumber;
    console.log(stageNumber);
  }
}


window.onload = () => {
  start_button.onclick = () => {
    if (input.value != "") {
      playerName = input.vlaue;
      rankingList.push(playerName);
      console.log(playerName);
    } else {
      playerName = "None";
      console.log(playerName);
      rankingList.push(playerName);
    }
    game(gameset);
    gameset = true;
  };
};

      
    </script>
  </body>
</html>




